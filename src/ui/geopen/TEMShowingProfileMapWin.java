/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ui.geopen;

import colorBar.geopen.Gradient;
import handler.geopen.TEMDatFileFilter;
import handler.geopen.TEMImageFileFilter;
import handler.geopen.TEMSourceData;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Toolkit;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import javaalgorithm.algorithm.Interpolation;
import javax.imageio.ImageIO;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.ListCellRenderer;
import javax.swing.SpinnerNumberModel;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;

/**
 *
 * @author Administrator
 */
public class TEMShowingProfileMapWin extends javax.swing.JFrame {

    private final int intialColorDivisions = 20;//与Gradient里的divisions 相同
    private double maxValue = -1;//设定显示最大电阻率
    private double minValue = -1;//设定显示最小电阻率
    private ColorCell[] colorCells = null;
    //创建剖面面板
    public MyProfilerMap profilerMap;
    public static boolean onlyOnceCalTempHorizonResis = false;
    private double maxIntervalZ = 0;//最大间距高程 计算最小比例
    private double maxElevation = 0;//记录最大高程值
    //存储电阻率值
    private double tempHorizonResis[][] = null;//存储最终值
    //保存dat文件
    private TEMDatFileFilter fileSave = new TEMDatFileFilter();
    private double[] offsetZ;//z高程偏移量
    private double logFactor = 1;
    //改变radio 也需要出现进度条
    private boolean changeRadio = false;

    /**
     * Creates new form TEMShowingProfileMapWin
     */
    public TEMShowingProfileMapWin() {

        initComponents();
        //定义电阻率剖面图
        profilerMap = new MyProfilerMap(TEMProcessingProgramWin.lineName);
//        profileMapPanel.add(profilerMap);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setColorParaDialog = new javax.swing.JDialog(TEMShowingProfileMapWin.this,true);
        jPanel1 = new javax.swing.JPanel();
        jPanel2 = new javax.swing.JPanel();
        lineRadioButton = new javax.swing.JRadioButton();
        jPanel6 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        logFactorsSpinner = new javax.swing.JSpinner();
        jLabel5 = new javax.swing.JLabel();
        startValueFormattedTextField = new javax.swing.JFormattedTextField();
        logRadioButton = new javax.swing.JRadioButton();
        jPanel5 = new javax.swing.JPanel();
        colorComboBox = new javax.swing.JComboBox(new JPanel[]{
            new ColorCell(Gradient.GRADIENT_RAINBOW, ""),
            new ColorCell(Gradient.GRADIENT_HEAT, ""),
            new ColorCell(Gradient.GRADIENT_HOT, ""),
            new ColorCell(Gradient.GRADIENT_GREEN_YELLOW_ORANGE_RED, ""),
            new ColorCell(Gradient.GRADIENT_BLUE_TO_RED, ""),
            new ColorCell(Gradient.GRADIENT_RED_TO_GREEN, ""),
            new ColorCell(Gradient.GRADIENT_MAROON_TO_GOLD, ""),
            new ColorCell(Gradient.GRADIENT_BLACK_TO_WHITE, ""),
            new ColorCell(Gradient.GRADIENT_ROY, "")
        });
        jLabel3 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        divisionsSpinner = new javax.swing.JSpinner();
        jPanel4 = new javax.swing.JPanel();
        jPanel3 = new javax.swing.JPanel();
        jLabel7 = new javax.swing.JLabel();
        minDepthSpinner = new javax.swing.JSpinner();
        jLabel8 = new javax.swing.JLabel();
        maxDepthSpinner = new javax.swing.JSpinner();
        jPanel7 = new javax.swing.JPanel();
        minSpinner = new javax.swing.JSpinner();
        maxSpinner = new javax.swing.JSpinner();
        jLabel4 = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        jPanel8 = new javax.swing.JPanel();
        jLabel10 = new javax.swing.JLabel();
        maxDistanceSpinner = new javax.swing.JSpinner();
        minDistanceSpinner = new javax.swing.JSpinner();
        jLabel9 = new javax.swing.JLabel();
        appplyButton = new javax.swing.JButton();
        okButton = new javax.swing.JButton();
        cancelButton = new javax.swing.JButton();
        buttonGroup = new javax.swing.ButtonGroup();
        jToolBar1 = new javax.swing.JToolBar();
        jLabel14 = new javax.swing.JLabel();
        saveDatButton = new javax.swing.JButton();
        jLabel12 = new javax.swing.JLabel();
        saveImageButton = new javax.swing.JButton();
        jLabel11 = new javax.swing.JLabel();
        setColorParaButton = new javax.swing.JButton();
        jLabel13 = new javax.swing.JLabel();
        waitingProgressBar = new javax.swing.JProgressBar();
        profileMapPanel = new javax.swing.JPanel();
        MenuBar = new javax.swing.JMenuBar();
        saveImageMenuItem = new javax.swing.JMenu();
        saveDatMenuItem = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        savePicMenuItem = new javax.swing.JMenuItem();
        EditMenu = new javax.swing.JMenu();
        colorsSetMenuItem = new javax.swing.JMenuItem();

        setColorParaDialog.setResizable(false);

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "设置", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("宋体", 0, 12), new java.awt.Color(0, 0, 255))); // NOI18N

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "模式", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("宋体", 0, 12), new java.awt.Color(0, 0, 255))); // NOI18N

        lineRadioButton.setSelected(true);
        lineRadioButton.setText("线性模式");
        lineRadioButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                lineRadioButtonActionPerformed(evt);
            }
        });

        jPanel6.setBorder(javax.swing.BorderFactory.createTitledBorder(""));

        jLabel2.setText("公比：");

        logFactorsSpinner.setModel(new javax.swing.SpinnerNumberModel(1.01d, 1.01d, 2.0d, 0.01d));
        logFactorsSpinner.setEnabled(false);

        jLabel5.setText("起始值：");

        startValueFormattedTextField.setFormatterFactory(new javax.swing.text.DefaultFormatterFactory(new javax.swing.text.NumberFormatter(new java.text.DecimalFormat("#0.00"))));
        startValueFormattedTextField.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        startValueFormattedTextField.setEnabled(false);

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel6Layout.createSequentialGroup()
                .addGap(0, 0, 0)
                .addComponent(jLabel5)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(startValueFormattedTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(logFactorsSpinner))
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel6Layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(startValueFormattedTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(logFactorsSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2)))
        );

        logRadioButton.setText("等比模式");
        logRadioButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                logRadioButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(lineRadioButton)
                    .addComponent(logRadioButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(0, 0, 0))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addComponent(lineRadioButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(logRadioButton)
                .addContainerGap(10, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        jPanel5.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "色标", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("宋体", 0, 12), new java.awt.Color(0, 0, 255))); // NOI18N

        ListCellRenderer renderer = new PanelComboBoxCellRenderer();
        colorComboBox.setRenderer(renderer);

        jLabel3.setText("颜色：");

        jLabel6.setText("分级数：");

        divisionsSpinner.setModel(new javax.swing.SpinnerNumberModel(20, 20, 200, 5));
        divisionsSpinner.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                divisionsSpinnerStateChanged(evt);
            }
        });

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addComponent(jLabel6)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(divisionsSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(colorComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0))
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel6)
                    .addComponent(divisionsSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel3)
                    .addComponent(colorComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, 0))
        );

        jPanel4.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "显示范围", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("宋体", 0, 12), new java.awt.Color(0, 0, 255))); // NOI18N

        jPanel3.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "深度", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("宋体", 0, 12), new java.awt.Color(0, 0, 255))); // NOI18N

        jLabel7.setText("起始值：");

        minDepthSpinner.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(0), Integer.valueOf(0), null, Integer.valueOf(1)));
        minDepthSpinner.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                minDepthSpinnerStateChanged(evt);
            }
        });

        jLabel8.setText("最终值：");

        maxDepthSpinner.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(0), Integer.valueOf(0), null, Integer.valueOf(1)));
        maxDepthSpinner.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                maxDepthSpinnerStateChanged(evt);
            }
        });

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(0, 0, 0)
                .addComponent(jLabel7)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(minDepthSpinner)
                .addGap(18, 18, 18)
                .addComponent(jLabel8)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(maxDepthSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(jLabel7)
                    .addComponent(minDepthSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel8)
                    .addComponent(maxDepthSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, 0))
        );

        jPanel7.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "电阻率", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("宋体", 0, 12), new java.awt.Color(0, 0, 255))); // NOI18N

        minSpinner.setModel(new javax.swing.SpinnerNumberModel(Double.valueOf(0.0d), Double.valueOf(0.0d), null, Double.valueOf(0.0010d)));

        maxSpinner.setModel(new javax.swing.SpinnerNumberModel(Double.valueOf(0.0d), Double.valueOf(0.0d), null, Double.valueOf(0.0010d)));

        jLabel4.setText("最终值：");

        jLabel1.setText("起始值：");

        javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);
        jPanel7.setLayout(jPanel7Layout);
        jPanel7Layout.setHorizontalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addGap(0, 0, 0)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(minSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(19, 19, 19)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(maxSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        jPanel7Layout.setVerticalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel7Layout.createSequentialGroup()
                .addGap(0, 0, 0)
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(jLabel1)
                    .addComponent(minSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4)
                    .addComponent(maxSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, 0))
        );

        jPanel8.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "水平距离", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("宋体", 0, 12), new java.awt.Color(0, 0, 255))); // NOI18N

        jLabel10.setText("最终值：");

        maxDistanceSpinner.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(0), Integer.valueOf(0), null, Integer.valueOf(1)));
        maxDistanceSpinner.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                maxDistanceSpinnerStateChanged(evt);
            }
        });

        minDistanceSpinner.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(0), Integer.valueOf(0), null, Integer.valueOf(1)));
        minDistanceSpinner.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                minDistanceSpinnerStateChanged(evt);
            }
        });

        jLabel9.setText("起始值：");

        javax.swing.GroupLayout jPanel8Layout = new javax.swing.GroupLayout(jPanel8);
        jPanel8.setLayout(jPanel8Layout);
        jPanel8Layout.setHorizontalGroup(
            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel8Layout.createSequentialGroup()
                .addComponent(jLabel9)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(minDistanceSpinner)
                .addGap(16, 16, 16)
                .addComponent(jLabel10)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(maxDistanceSpinner)
                .addGap(0, 0, 0))
        );
        jPanel8Layout.setVerticalGroup(
            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel8Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(jLabel10)
                    .addComponent(maxDistanceSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(minDistanceSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel9))
                .addGap(0, 0, 0))
        );

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(jPanel7, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(jPanel8, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addGap(0, 0, 0)
                .addComponent(jPanel8, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0))
        );

        appplyButton.setText("应用");
        appplyButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                appplyButtonActionPerformed(evt);
            }
        });

        okButton.setText("确定");
        okButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                okButtonActionPerformed(evt);
            }
        });

        cancelButton.setText("取消");
        cancelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cancelButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(appplyButton, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(okButton, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(23, 23, 23)
                .addComponent(cancelButton)
                .addContainerGap())
        );

        jPanel1Layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {appplyButton, cancelButton, okButton});

        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(0, 0, 0)
                .addComponent(jPanel5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(appplyButton, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(okButton)
                    .addComponent(cancelButton, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );

        jPanel1Layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {appplyButton, cancelButton, okButton});

        javax.swing.GroupLayout setColorParaDialogLayout = new javax.swing.GroupLayout(setColorParaDialog.getContentPane());
        setColorParaDialog.getContentPane().setLayout(setColorParaDialogLayout);
        setColorParaDialogLayout.setHorizontalGroup(
            setColorParaDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(setColorParaDialogLayout.createSequentialGroup()
                .addGap(0, 0, 0)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 10, Short.MAX_VALUE))
        );
        setColorParaDialogLayout.setVerticalGroup(
            setColorParaDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        buttonGroup.add(logRadioButton);
        buttonGroup.add(lineRadioButton);

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setIconImage(Toolkit.getDefaultToolkit().createImage(ClassLoader.getSystemResource("pic/geopen/GP.png")));
        setMinimumSize(new java.awt.Dimension(200, 200));
        setResizable(false);

        jToolBar1.setFloatable(false);
        jToolBar1.setRollover(true);

        jLabel14.setForeground(new java.awt.Color(204, 204, 204));
        jLabel14.setText(" ");
        jToolBar1.add(jLabel14);

        saveDatButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/pic/geopen/savedat28.png"))); // NOI18N
        saveDatButton.setToolTipText("dat文件");
        saveDatButton.setFocusable(false);
        saveDatButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        saveDatButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        saveDatButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveDatButtonActionPerformed(evt);
            }
        });
        jToolBar1.add(saveDatButton);

        jLabel12.setForeground(new java.awt.Color(204, 204, 204));
        jLabel12.setText("|");
        jToolBar1.add(jLabel12);

        saveImageButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/pic/geopen/pictrue28.png"))); // NOI18N
        saveImageButton.setToolTipText("图片");
        saveImageButton.setFocusable(false);
        saveImageButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        saveImageButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        saveImageButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveImageButtonActionPerformed(evt);
            }
        });
        jToolBar1.add(saveImageButton);

        jLabel11.setForeground(new java.awt.Color(204, 204, 204));
        jLabel11.setText("|");
        jToolBar1.add(jLabel11);

        setColorParaButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/pic/geopen/colorset32.png"))); // NOI18N
        setColorParaButton.setToolTipText("显示设置");
        setColorParaButton.setFocusable(false);
        setColorParaButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        setColorParaButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        setColorParaButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                setColorParaButtonActionPerformed(evt);
            }
        });
        jToolBar1.add(setColorParaButton);

        jLabel13.setForeground(new java.awt.Color(204, 204, 204));
        jLabel13.setText(" ");
        jToolBar1.add(jLabel13);

        waitingProgressBar.setIndeterminate(true);
        waitingProgressBar.setMaximumSize(new java.awt.Dimension(200, 19));
        waitingProgressBar.setMinimumSize(new java.awt.Dimension(200, 19));
        waitingProgressBar.setPreferredSize(new java.awt.Dimension(200, 19));
        waitingProgressBar.setString("电阻率剖面生成中...");
        waitingProgressBar.setStringPainted(true);
        jToolBar1.add(waitingProgressBar);

        profileMapPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(null, " ", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.BELOW_BOTTOM, new java.awt.Font("宋体", 0, 1))); // NOI18N
        profileMapPanel.setLayout(new java.awt.GridLayout(1, 0));

        saveImageMenuItem.setMnemonic(KeyEvent.VK_F);
        saveImageMenuItem.setText("文件(F)");

        saveDatMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        saveDatMenuItem.setIcon(new javax.swing.ImageIcon(getClass().getResource("/pic/geopen/save16.png"))); // NOI18N
        saveDatMenuItem.setText("保存(S)");
        saveDatMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveDatMenuItemActionPerformed(evt);
            }
        });
        saveImageMenuItem.add(saveDatMenuItem);
        saveImageMenuItem.add(jSeparator1);

        savePicMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_P, java.awt.event.InputEvent.CTRL_MASK));
        savePicMenuItem.setIcon(new javax.swing.ImageIcon(getClass().getResource("/pic/geopen/pictrue16.png"))); // NOI18N
        savePicMenuItem.setText("图片(P)");
        savePicMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                savePicMenuItemActionPerformed(evt);
            }
        });
        saveImageMenuItem.add(savePicMenuItem);

        MenuBar.add(saveImageMenuItem);

        EditMenu.setMnemonic(KeyEvent.VK_S);
        EditMenu.setText("设置(S)");

        colorsSetMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_C, java.awt.event.InputEvent.CTRL_MASK));
        colorsSetMenuItem.setIcon(new javax.swing.ImageIcon(getClass().getResource("/pic/geopen/colorset16.png"))); // NOI18N
        colorsSetMenuItem.setText("显示设置(C)");
        colorsSetMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                colorsSetMenuItemActionPerformed(evt);
            }
        });
        EditMenu.add(colorsSetMenuItem);

        MenuBar.add(EditMenu);

        setJMenuBar(MenuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jToolBar1, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
            .addComponent(profileMapPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jToolBar1, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(profileMapPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 339, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void setColorParaButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_setColorParaButtonActionPerformed
        // TODO add your handling code here:
        showColorSetDia();
    }//GEN-LAST:event_setColorParaButtonActionPerformed
    public void showColorSetDia() {
        setColorParaDialog.pack();
        ShowScope.setLocation(setColorParaDialog);
        setColorParaDialog.setVisible(true);
    }
    private void divisionsSpinnerStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_divisionsSpinnerStateChanged
        // TODO add your handling code here:
        int divisions = (Integer) divisionsSpinner.getValue();//默认多了前后两个 
        int indexColorBar = colorComboBox.getSelectedIndex();
        if (divisions >= intialColorDivisions) {
            //必须用模型model进行处理 其他方法不可以
            DefaultComboBoxModel model = (DefaultComboBoxModel) colorComboBox.getModel();
            model.removeAllElements();
            colorCells = new ColorCell[]{
                new ColorCell(Gradient.createMultiGradient(//rainbow
                new Color[]{new Color(181, 32, 255), Color.blue, Color.green,
                    Color.yellow, Color.orange, Color.red}, divisions), ""),
                new ColorCell(Gradient.createMultiGradient(//heat
                new Color[]{Color.black, new Color(105, 0, 0),
                    new Color(192, 23, 0), new Color(255, 150, 38), Color.white},
                divisions), ""),
                new ColorCell(Gradient.createMultiGradient(new Color[]{//hot
                    Color.black, new Color(87, 0, 0), Color.red, Color.orange,
                    Color.yellow, Color.white}, divisions), ""),
                new ColorCell(Gradient.createMultiGradient(//GRADIENT_GREEN_YELLOW_ORANGE_RED
                new Color[]{Color.green, Color.yellow, Color.orange, Color.red},
                divisions), ""),
                new ColorCell(Gradient.createGradient(//GRADIENT_BLUE_TO_RED
                Color.BLUE, Color.RED, divisions), ""),
                new ColorCell(Gradient.createGradient(//GRADIENT_RED_TO_GREEN
                Color.RED, Color.GREEN, divisions), ""),
                new ColorCell(Gradient.createGradient(//GRADIENT_MAROON_TO_GOLD
                new Color(0xA0, 0x00, 0x00), new Color(0xFF, 0xFF, 0x00), divisions), ""),
                new ColorCell(Gradient.createGradient(//GRADIENT_BLACK_TO_WHITE
                Color.BLACK, Color.WHITE, divisions), ""),
                new ColorCell(Gradient.createMultiGradient(new Color[]{//GRADIENT_ROY
                    Color.red, Color.orange, Color.yellow}, divisions), ""),};

            for (int i = 0; i < colorCells.length; i++) {
                model.addElement(colorCells[i]);
            }
            //选择起初选择的色标
            colorComboBox.setSelectedIndex(indexColorBar);
            Gradient.divisions = (Integer) divisionsSpinner.getValue();
        }
    }//GEN-LAST:event_divisionsSpinnerStateChanged

    private void logRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_logRadioButtonActionPerformed
        // TODO add your handling code here:
//        changeRadio = true;
        radioChange();//判断是否改变了数值
        logFactorsSpinner.setEnabled(true);
        startValueFormattedTextField.setEnabled(true);
        //设定划分的色标的最大各数
        divisionsSpinner.setValue(20);//还原为最小个数
        SpinnerNumberModel divisionsSpinnerModel = (SpinnerNumberModel) divisionsSpinner.getModel();
        divisionsSpinnerModel.setMaximum(20);
    }//GEN-LAST:event_logRadioButtonActionPerformed
    public void radioChange() {
        int minDepth = Integer.parseInt(minDepthSpinner.getValue().toString());
        int maxDepth = Integer.parseInt(maxDepthSpinner.getValue().toString());
        int minDistance = Integer.parseInt(minDistanceSpinner.getValue().toString());
        int maxDistance = Integer.parseInt(maxDistanceSpinner.getValue().toString());
        if (minDepth == profilerMap.minDepthInitial
                && maxDepth == profilerMap.maxDepthInitial
                && minDistance == profilerMap.minDistanceInitial
                && maxDistance == profilerMap.maxDistanceInitial) {//只改变颜色
            changeRadio = true;
        }
    }
    private void lineRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_lineRadioButtonActionPerformed
        // TODO add your handling code here:
//        changeRadio = true;
        radioChange();//判断是否改变了数值
        logFactorsSpinner.setEnabled(false);
        startValueFormattedTextField.setEnabled(false);
        //设定划分的色标的最大各数
        SpinnerNumberModel divisionsSpinnerModel = (SpinnerNumberModel) divisionsSpinner.getModel();
        divisionsSpinnerModel.setMaximum(200);
    }//GEN-LAST:event_lineRadioButtonActionPerformed

    private void appplyButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_appplyButtonActionPerformed
        // TODO add your handling code here:
        changeRadioButton();
    }//GEN-LAST:event_appplyButtonActionPerformed
    public void changeRadioButton() {
        int minDepth = Integer.parseInt(minDepthSpinner.getValue().toString());
        int maxDepth = Integer.parseInt(maxDepthSpinner.getValue().toString());
        int minDistance = Integer.parseInt(minDistanceSpinner.getValue().toString());
        int maxDistance = Integer.parseInt(maxDistanceSpinner.getValue().toString());
        //自定义面板的绘制  
        if (minDepth == profilerMap.minDepthInitial
                && maxDepth == profilerMap.maxDepthInitial
                && minDistance == profilerMap.minDistanceInitial
                && maxDistance == profilerMap.maxDistanceInitial && changeRadio == false) {//只改变颜色
            profileMapPanel.repaint();
//            //重新赋值
//            profilerMap.minDepthInitial = minDepth;
//            profilerMap.maxDepthInitial = maxDepth;
//            profilerMap.minDistanceInitial = minDistance;
//            profilerMap.maxDistanceInitial = maxDistance;
        } else {//需重新计算深度和水平距离
            waitingProgressBar.setVisible(true);
            new Thread(new Runnable() {
                @Override
                public void run() {
                    profilerMap.getTempHorizonResis();
                }
            }).start();
        }
        //绘制完需要重新赋值
        changeRadio = false;
        //重新赋值
        profilerMap.minDepthInitial = minDepth;
        profilerMap.maxDepthInitial = maxDepth;
        profilerMap.minDistanceInitial = minDistance;
        profilerMap.maxDistanceInitial = maxDistance;
    }

    private void colorsSetMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_colorsSetMenuItemActionPerformed
        // TODO add your handling code here:
        showColorSetDia();
    }//GEN-LAST:event_colorsSetMenuItemActionPerformed

    private void maxDepthSpinnerStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_maxDepthSpinnerStateChanged
        // TODO add your handling code here:
        int minDepthValue = Integer.parseInt(minDepthSpinner.getValue().toString());
        int maxDepthValue = Integer.parseInt(maxDepthSpinner.getValue().toString());
        if (maxDepthValue <= minDepthValue) {
            maxDepthSpinner.setValue(minDepthValue + 1);
            JOptionPane.showMessageDialog(setColorParaDialog, "小于最小深度" + minDepthValue);
            return;
        }
    }//GEN-LAST:event_maxDepthSpinnerStateChanged

    private void minDepthSpinnerStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_minDepthSpinnerStateChanged
        // TODO add your handling code here:
        int minDepthValue = Integer.parseInt(minDepthSpinner.getValue().toString());
        int maxDepthValue = Integer.parseInt(maxDepthSpinner.getValue().toString());
        if (maxDepthValue <= minDepthValue) {
            minDepthSpinner.setValue(maxDepthValue - 1);
            JOptionPane.showMessageDialog(setColorParaDialog, "大于最大深度" + maxDepthValue);
            return;
        }
    }//GEN-LAST:event_minDepthSpinnerStateChanged

    private void minDistanceSpinnerStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_minDistanceSpinnerStateChanged
        // TODO add your handling code here:
        int minDistanceValue = Integer.parseInt(minDistanceSpinner.getValue().toString());
        int maxDistanceValue = Integer.parseInt(maxDistanceSpinner.getValue().toString());
        if (maxDistanceValue <= minDistanceValue) {
            minDepthSpinner.setValue(maxDistanceValue - 1);
            JOptionPane.showMessageDialog(setColorParaDialog, "大于最大距离" + maxDistanceValue);
            return;
        }
    }//GEN-LAST:event_minDistanceSpinnerStateChanged

    private void maxDistanceSpinnerStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_maxDistanceSpinnerStateChanged
        // TODO add your handling code here:
        int minDistanceValue = Integer.parseInt(minDistanceSpinner.getValue().toString());
        int maxDistanceValue = Integer.parseInt(maxDistanceSpinner.getValue().toString());
        if (maxDistanceValue <= minDistanceValue) {
            maxDistanceSpinner.setValue(minDistanceValue + 1);
            JOptionPane.showMessageDialog(setColorParaDialog, "小于最小距离" + minDistanceValue);
            return;
        }
    }//GEN-LAST:event_maxDistanceSpinnerStateChanged

    private void saveDatButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveDatButtonActionPerformed
        // TODO add your handling code here:
        saveDatFormat();
    }//GEN-LAST:event_saveDatButtonActionPerformed

    private void saveImageButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveImageButtonActionPerformed
        // TODO add your handling code here:
        saveImage(profilerMap);
    }//GEN-LAST:event_saveImageButtonActionPerformed

    private void saveDatMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveDatMenuItemActionPerformed
        // TODO add your handling code here:
        saveDatFormat();
    }//GEN-LAST:event_saveDatMenuItemActionPerformed

    private void savePicMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_savePicMenuItemActionPerformed
        // TODO add your handling code here:
        saveImage(profilerMap);
    }//GEN-LAST:event_savePicMenuItemActionPerformed

    private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okButtonActionPerformed
        // TODO add your handling code here:
        appplyButtonActionPerformed(evt);
        setColorParaDialog.setVisible(false);
    }//GEN-LAST:event_okButtonActionPerformed

    private void cancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cancelButtonActionPerformed
        // TODO add your handling code here:
        setColorParaDialog.setVisible(false);
    }//GEN-LAST:event_cancelButtonActionPerformed
    public void saveImage(JPanel panel) {
        TEMImageFileFilter imageChooser = new TEMImageFileFilter();
        if (imageChooser.showSaveDialog(this) == TEMImageFileFilter.APPROVE_OPTION) {
            // 获取当前路径
            File currentDirectory = imageChooser.getCurrentDirectory();
            // 获取文件名
            String fileName = imageChooser.getSelectedFile().getName();
            String[] readFile = fileName.split("[.]");
            // 获取后缀名
            String suf = imageChooser.getSuf();
            // 组合保存路径
            String savePath = currentDirectory + "\\" + readFile[0] + "."
                    + suf;
            File imageMerge = new File(savePath);//监测是否有重复的
            if (imageMerge.exists()) {
                int count = JOptionPane.showConfirmDialog(this, "文件已存在,是否覆盖？", "文件存在", JOptionPane.OK_OPTION);
                if (count == 0) {
                    try {
                        // 将图片写到保存路径
                        exportOtherShapesImage(imageMerge, panel, suf);
                    } catch (Exception ie) {
                    }
                } else {
                    saveImage(panel);
                }
            } else {
                exportOtherShapesImage(imageMerge, panel, suf);
            }
        }
    }

    public boolean exportOtherShapesImage(File f, JPanel panel, String suffix) {
        Dimension imageSize = panel.getSize();
        BufferedImage image = new BufferedImage(imageSize.width, imageSize.height, BufferedImage.TYPE_INT_RGB);
        Graphics2D g = image.createGraphics();
        panel.paint(g);
        g.dispose();
        try {
            ImageIO.write(image, suffix, f);
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    public void saveDatFormat() {
        if (fileSave.showSaveDialog(this) == TEMDatFileFilter.APPROVE_OPTION) {
            // 获取当前路径
            File currentDirectory = fileSave.getCurrentDirectory();
            // 获取文件名
            String fileName = fileSave.getSelectedFile().getName();
            String[] readFile = fileName.split("[.]");
            File testFile = new File(currentDirectory + "\\" + readFile[0] + ".dat");//监测是否有重复的
            if (!testFile.exists()) {
                saveMethod(currentDirectory, readFile[0]);
            } else {
                int count = JOptionPane.showConfirmDialog(null, "文件已存在,是否覆盖？", "文件存在", JOptionPane.OK_OPTION);
                if (count == 0) {
                    saveMethod(currentDirectory, readFile[0]);
                } else {
                    saveDatFormat();
                }
            }
        }
    }

    public void saveMethod(File currentDirectory, String fileName) {
        String savePath = currentDirectory + "\\" + fileName + ".dat";
        File file = new File(savePath);
        try {
            file.createNewFile();
            FileWriter fw = new FileWriter(file);
            BufferedWriter dos = new BufferedWriter(fw);
            DecimalFormat df = new DecimalFormat("0.00000E00");//转换格式
            DecimalFormat dfError = new DecimalFormat("0.0000");//转换格式
            ArrayList linePoints = new ArrayList();//必须是Arraylist获得xy集合
            linePoints = (ArrayList) TEMSourceData.lineName_XYList.get(TEMProcessingProgramWin.lineName);
            int counts = linePoints.size(); //测点数 用户所选的测点数
            String singleFileName = "";
            //起点坐标
            singleFileName = TEMSourceData.xy_fileName.get(linePoints.get(0)).toString();//获得文件名
            ArrayList<Double> posXY = (ArrayList) linePoints.get(0);//单点坐标
            double startX = posXY.get(0);
            double startY = posXY.get(1);
//            System.out.println(linePoints);
            for (int p = 0; p < counts; p++) {
                ArrayList<Double> tempPosXY = (ArrayList) linePoints.get(p);//单点坐标
                double x = tempPosXY.get(0);
                double y = tempPosXY.get(1);
                double distance = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                //获得单个测点的所有数据点数据
                singleFileName = TEMSourceData.xy_fileName.get(linePoints.get(p)).toString();//获得文件名
                double z = TEMSourceData.z_fileName.get(singleFileName);//获得高程Z
                ArrayList voltage_time = TEMSourceData.integrationValue.get(singleFileName);
                //获得电阻率
                XYSeriesCollection xyseriescollection = new XYSeriesCollection();
                TEMTime_Resis_VoltWin time_resis_rolt = new TEMTime_Resis_VoltWin(xyseriescollection);
                ArrayList<ArrayList> rdlist = time_resis_rolt.extractResis_DepthList((ArrayList) voltage_time.get(0), (ArrayList) voltage_time.get(1),
                        (ArrayList) voltage_time.get(2), (ArrayList) voltage_time.get(3), (ArrayList) voltage_time.get(4), (ArrayList) voltage_time.get(5), (ArrayList) voltage_time.get(6));
                int singleDataPoints = ((ArrayList) voltage_time.get(0)).size();//数据点的个数
                for (int j = 0; j < singleDataPoints; j++) {
                    if (p == 0 && j == 0) {
                        dos.write("NO." + " \t"
                                + "X(m)" + " \t"
                                + "Y(m)" + " \t"
                                + "Z(m)" + " \t"
                                + "T(ms)" + " \t"
                                + "Voltage(nv/(Am^2))" + " \t"
                                + "Distance(m)" + " \t"
                                + "Resistivity(ohm.m)" + " \t"
                                + "Depth(m)" + "\r\n");
                    }
                    dos.write(String.valueOf(
                            p + " \t"
                            + x + " \t"
                            + y + " \t"
                            + z + " \t"
                            + df.format(((Double) ((ArrayList) voltage_time.get(1)).get(j))) + " \t"
                            + df.format(((Double) ((ArrayList) voltage_time.get(0)).get(j)) * 1000000) + " \t"
                            + dfError.format(distance) + " \t"
                            + dfError.format(((ArrayList) rdlist.get(0)).get(j)) + " \t"
                            + dfError.format(z - (Double) ((ArrayList) rdlist.get(1)).get(j)) + "\r\n"));
                }
            }
            dos.close();
        } catch (Exception ex) {
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu EditMenu;
    private javax.swing.JMenuBar MenuBar;
    private javax.swing.JButton appplyButton;
    private javax.swing.ButtonGroup buttonGroup;
    private javax.swing.JButton cancelButton;
    private javax.swing.JComboBox colorComboBox;
    private javax.swing.JMenuItem colorsSetMenuItem;
    private javax.swing.JSpinner divisionsSpinner;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JPanel jPanel8;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    private javax.swing.JToolBar jToolBar1;
    private javax.swing.JRadioButton lineRadioButton;
    private javax.swing.JSpinner logFactorsSpinner;
    private javax.swing.JRadioButton logRadioButton;
    private javax.swing.JSpinner maxDepthSpinner;
    private javax.swing.JSpinner maxDistanceSpinner;
    private javax.swing.JSpinner maxSpinner;
    private javax.swing.JSpinner minDepthSpinner;
    private javax.swing.JSpinner minDistanceSpinner;
    private javax.swing.JSpinner minSpinner;
    private javax.swing.JButton okButton;
    public javax.swing.JPanel profileMapPanel;
    private javax.swing.JButton saveDatButton;
    private javax.swing.JMenuItem saveDatMenuItem;
    private javax.swing.JButton saveImageButton;
    private javax.swing.JMenu saveImageMenuItem;
    private javax.swing.JMenuItem savePicMenuItem;
    private javax.swing.JButton setColorParaButton;
    private javax.swing.JDialog setColorParaDialog;
    private javax.swing.JFormattedTextField startValueFormattedTextField;
    private javax.swing.JProgressBar waitingProgressBar;
    // End of variables declaration//GEN-END:variables

    /**
     * **********************************添加色标面板到jcombobox中*****************************************************
     */
    class PanelComboBoxCellRenderer implements ListCellRenderer {

        @Override
        public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
            if (value instanceof JPanel) {
                if (isSelected) {//设置选中时的背景色
                    ((JPanel) value).setBackground(Color.white);
                } else {
                    ((JPanel) value).setBackground(Color.white);
                }
                return (JPanel) value;
            }
            return null;
        }
    }

    class ColorCell extends JPanel {

        private Color[] cellColor;
        private JPanel colorPanel;
//    private JLabel colorNameLabel;
        private String colorName;

        public ColorCell(Color[] color, String name) {
            this.cellColor = color;
            this.colorName = name;
            int width = 180;
            int hight = 25;
            int divisions = cellColor.length;
            colorPanel = new GradientsPanel(width, hight, divisions);
            colorPanel.setPreferredSize(new Dimension(width, hight));
            setLayout(new FlowLayout(FlowLayout.LEFT, 2, 0));
            add(colorPanel);
        }

        public Color[] getCellColor() {
            return cellColor;
        }

        public void setCellColor(Color[] cellColor) {
            this.cellColor = cellColor;
        }

        public String getColorName() {
            return colorName;
        }

        public void setColorName(String colorName) {
            this.colorName = colorName;
        }

        class GradientsPanel extends JPanel {

            int width = -1;
            int hight = -1;
            int divisions = -1;

            public GradientsPanel(int width, int hight, int divisions) {
                this.width = width;
                this.hight = hight;
                this.divisions = divisions;
            }

            public void paint(Graphics g) {
                super.paint(g);
                Graphics2D g2d = (Graphics2D) g;
                Color[] colors = cellColor;
                double interval = width * 1.0 / divisions;
                for (int i = 0; i < colors.length; i++) {
                    g2d.setColor(colors[i]);
                    g2d.fillRect((int) (i * interval), 0, (int) Math.ceil(interval), hight - 10);
                }
            }
        }
    }

    /**
     * **********************************自定义的剖面面板*****************************************************
     */
    class MyProfilerMap extends JPanel {

        private int offsetX = 100;
        private int offsetZTop = 100;
        private int offsetZBottom = 100;
        private int xDistance = 0;
        private int maxDepth = 0;
        private double xInterval = 0;//两个像素点之间代表的实际距离
        private double depthInterval = 0;
        private String lineName = "";
        private double maxResis = -1;
        private int singleCharWidth = 6;//单个字符的宽度
        //记录第一次获得的最小最大深度 和最长最短距离
        private int minDepthInitial = Integer.parseInt(minDepthSpinner.getValue().toString());
        private int maxDepthInitial = Integer.parseInt(maxDepthSpinner.getValue().toString());
        private int minDistanceInitial = Integer.parseInt(minDistanceSpinner.getValue().toString());
        private int maxDistanceInitial = Integer.parseInt(maxDistanceSpinner.getValue().toString());

        public MyProfilerMap(String lineName) {
            this.lineName = lineName;
        }

        public void paint(Graphics g) {
            super.paint(g);
            //渲染背景
            int width = getWidth();
            int height = getHeight();
            g.setColor(Color.WHITE);
            g.fillRect(0, 0, width, height);
            g.setColor(Color.black);
            g.drawRect(0, 0, width - 1, height - 1);
            //绘图
            int usedWidth = width - offsetX * 2;
            int usedHeight = height - offsetZBottom - offsetZTop;
            //必须是Arraylist
//            ArrayList linePoints = new ArrayList();
//            linePoints = (ArrayList) TEMSourceData.lineName_XYList.get(lineName);
//            //计算最大深度和水平距离
//            boolean back = calMaxDepthAndMaxDistance(linePoints);//如果深度大于1m
//            if (back == false) {
//                String str = "反演深度不足1m,请检查参数设置！";
//                g.setColor(Color.red);
//                g.drawString(str, width / 2 - str.length() * 4, height / 2);
//                return;
//            } else {
//                //只赋值一次
//                if (onlyOnceCalTempHorizonResis == false) {
//                    onlyOnceCalTempHorizonResis = true;
//                    setValue();//先进行calMaxDepthAndMaxDistance
//                }
//                //数据绘图
//                int minDepth = Integer.parseInt(minDepthSpinner.getValue().toString());
//                int maxDepth = Integer.parseInt(maxDepthSpinner.getValue().toString());
//                int minDistance = Integer.parseInt(minDistanceSpinner.getValue().toString());
//                int maxDistance = Integer.parseInt(maxDistanceSpinner.getValue().toString());
//                double maxDepth_Z = maxDepth - minDepth + maxIntervalZ;//添加最大高程差 实际距离
//                double depthInterval_Z = maxDepth_Z / usedHeight;
//                double verticalIntervalPoints_Z = maxIntervalZ / depthInterval_Z;//最大高程差 对应的 像素长度
//                if (tempHorizonResis != null) {
//                    sectionChoice(tempHorizonResis, usedHeight - (int) Math.round(verticalIntervalPoints_Z), usedWidth, minDistance, maxDistance, minDepth, maxDepth, g);
//                    //绘制坐标
//                    setAixs(g, usedHeight, maxIntervalZ, usedWidth, minDistance, maxDistance, minDepth, maxDepth, minValue, maxValue, logFactor);
//                }
//                double[][] tempHorizonResis = getInvertedDepthMyProfiler(linePoints, usedHeight - (int) Math.round(verticalIntervalPoints_Z),
//                        usedWidth, minDistance, maxDistance, minDepth, maxDepth, xDistance, this.maxDepth);
//                Task task = new Task(linePoints, usedHeight - (int) Math.round(verticalIntervalPoints_Z), usedWidth,
//                        verticalIntervalPoints_Z, minDistance, maxDistance, minDepth, maxDepth, xDistance, this.maxDepth, g);
//                task.addPropertyChangeListener(this);
//                task.execute();
//                double[][] tempHorizonResis = new double[usedHeight][usedWidth];
            //更新比例 当界面变化时
//            }
            if (tempHorizonResis != null) {//只有电阻率数组存在的时候
                //数据绘图
                int minDepth = Integer.parseInt(minDepthSpinner.getValue().toString());
                int maxDepth = Integer.parseInt(maxDepthSpinner.getValue().toString());
                int minDistance = Integer.parseInt(minDistanceSpinner.getValue().toString());
                int maxDistance = Integer.parseInt(maxDistanceSpinner.getValue().toString());
                double maxDepth_Z = maxDepth - minDepth + maxIntervalZ;//添加最大高程差 实际距离
                double depthInterval_Z = maxDepth_Z / usedHeight;
                double verticalIntervalPoints_Z = maxIntervalZ / depthInterval_Z;//最大高程差 对应的 像素长度
                sectionChoice(tempHorizonResis, usedHeight - (int) Math.round(verticalIntervalPoints_Z), usedWidth, minDistance, maxDistance, minDepth, maxDepth, g);
                //绘制坐标
                setAixs(g, usedHeight, maxElevation, usedWidth, minDistance, maxDistance, minDepth, maxDepth, minValue, maxValue, logFactor);
            }
        }

        public void getTempHorizonResis() {
            //添加面板
            profileMapPanel.add(profilerMap);
            //必须是Arraylist
            ArrayList linePoints = new ArrayList();
            linePoints = (ArrayList) TEMSourceData.lineName_XYList.get(lineName);
            boolean back = calMaxDepthAndMaxDistance(linePoints);//如果深度大于1m
            if (back == false) {
                JOptionPane.showMessageDialog(this, "反演深度不足1m,请检查参数设置！");
                waitingProgressBar.setVisible(false);
                TEMShowingProfileMapWin.this.dispose();
                return;
            }
            int width = getWidth();
            int height = getHeight();
            int usedWidth = width - offsetX * 2;
            int usedHeight = height - offsetZBottom - offsetZTop;
//            boolean back = calMaxDepthAndMaxDistance(linePoints);//如果深度大于1m
            //数据绘图
            if (onlyOnceCalTempHorizonResis == false) {
                onlyOnceCalTempHorizonResis = true;
                setValue();//先进行calMaxDepthAndMaxDistance
                minDepthInitial = Integer.parseInt(minDepthSpinner.getValue().toString());
                maxDepthInitial = Integer.parseInt(maxDepthSpinner.getValue().toString());
                minDistanceInitial = Integer.parseInt(minDistanceSpinner.getValue().toString());
                maxDistanceInitial = Integer.parseInt(maxDistanceSpinner.getValue().toString());
            }
            int minDepth = Integer.parseInt(minDepthSpinner.getValue().toString());
            int maxDepth = Integer.parseInt(maxDepthSpinner.getValue().toString());
            int minDistance = Integer.parseInt(minDistanceSpinner.getValue().toString());
            int maxDistance = Integer.parseInt(maxDistanceSpinner.getValue().toString());
            double maxDepth_Z = maxDepth - minDepth + maxIntervalZ;//添加最大高程差 实际距离
            double depthInterval_Z = maxDepth_Z / usedHeight;
            double verticalIntervalPoints_Z = maxIntervalZ / depthInterval_Z;//最大高程差 对应的 像素长度
            tempHorizonResis = getInvertedDepthMyProfiler(linePoints, usedHeight - (int) Math.round(verticalIntervalPoints_Z),
                    usedWidth, minDistance, maxDistance, minDepth, maxDepth, xDistance, this.maxDepth);
        }

        public void setValue() {
            //*****************************开始对色标设置对话框进行初始化**********************************
            startValueFormattedTextField.setValue(0);
            divisionsSpinnerStateChanged(null);//先给colorCells 赋值
            //**********************************给起始值和最终值的数值********************************
            minSpinner.setValue(0);
            maxSpinner.setValue(maxResis);
            maxSpinner.setToolTipText("最大电阻率值：" + maxResis);
            //********************深度水平距离范围赋值************************************************
            minDepthSpinner.setValue(0);
            maxDepthSpinner.setValue(this.maxDepth);
            maxDepthSpinner.setToolTipText("最大深度：" + this.maxDepth);
            minDistanceSpinner.setValue(0);
            maxDistanceSpinner.setValue(xDistance);
            maxDistanceSpinner.setToolTipText("最大距离：" + xDistance);
            //限制最大深度和最长距离 和电阻率
            SpinnerNumberModel modelstartDep = (SpinnerNumberModel) minDepthSpinner.getModel();
            modelstartDep.setMaximum(this.maxDepth);
            SpinnerNumberModel modelendDep = (SpinnerNumberModel) maxDepthSpinner.getModel();
            modelendDep.setMaximum(this.maxDepth);
            SpinnerNumberModel modelminDistance = (SpinnerNumberModel) minDistanceSpinner.getModel();
            SpinnerNumberModel modelmaxDistance = (SpinnerNumberModel) maxDistanceSpinner.getModel();
            modelminDistance.setMaximum(xDistance);
            modelmaxDistance.setMaximum(xDistance);
        }

        /**
         * 计算最大深度 并初始化色标数组 赋值最大最小值
         *
         * @param linePoints
         * @return
         */
        public boolean calMaxDepthAndMaxDistance(ArrayList linePoints) {
            String fileName = "";
            double maxDepth = -1;
            //求该侧线最大深度并记录最大深度的测点
            double minz = -1;
            for (int i = 0; i < linePoints.size(); i++) {
                fileName = TEMSourceData.xy_fileName.get((ArrayList) linePoints.get(i)).toString();
                ArrayList voltage_time = TEMSourceData.integrationValue.get(fileName);
                XYSeriesCollection xyseriescollection = new XYSeriesCollection();
                TEMTime_Resis_VoltWin time_resis_rolt = new TEMTime_Resis_VoltWin(xyseriescollection);
                //获得深度与电阻率值
                XYSeries resis_depthSeries = time_resis_rolt.extractResis_Depth((ArrayList) voltage_time.get(0), (ArrayList) voltage_time.get(1),
                        (ArrayList) voltage_time.get(2), (ArrayList) voltage_time.get(3), (ArrayList) voltage_time.get(4), (ArrayList) voltage_time.get(5), (ArrayList) voltage_time.get(6));
                if (i == 0) {
                    maxResis = resis_depthSeries.getMaxX();
                    maxDepth = resis_depthSeries.getMaxY();
                }
                if (maxResis < resis_depthSeries.getMaxX()) {
                    maxResis = resis_depthSeries.getMaxX();
                }
                if (maxDepth < resis_depthSeries.getMaxY()) {
                    maxDepth = resis_depthSeries.getMaxY();
                }
                //计算选定测点最大最小高程值
                double z = Double.parseDouble(TEMSourceData.z_fileName.get(fileName).toString());
                if (i == 0) {
                    minz = z;
                    maxElevation = z;
                }
                if (minz > z) {
                    minz = z;
                }
                if (maxElevation < z) {
                    maxElevation = z;
                }
            }
            maxIntervalZ = maxElevation - minz;//最大间隔
            //**********************************最大深度和最大水平距离
            int counts = linePoints.size();
            double minX = -1;
            double maxX = -1;
            double minY = -1;
            double maxY = -1;
            for (int i = 0; i < counts; i++) {
                ArrayList xy = new ArrayList();
                xy = (ArrayList) linePoints.get(i);
                if (i == 0) {
                    minX = (Double) xy.get(0);
                    maxX = (Double) xy.get(0);
                    minY = (Double) xy.get(1);
                    maxY = (Double) xy.get(1);
                }
                if (minX > (Double) xy.get(0)) {
                    minX = (Double) xy.get(0);
                }
                if (maxX < (Double) xy.get(0)) {
                    maxX = (Double) xy.get(0);
                }
                if (minY > (Double) xy.get(1)) {
                    minY = (Double) xy.get(1);
                }
                if (maxY < (Double) xy.get(1)) {
                    maxY = (Double) xy.get(1);
                }
            }
            //水平距离
            xDistance = (int) Math.sqrt(Math.pow(maxX - minX, 2) + Math.pow(maxY - minY, 2));
            this.maxDepth = (int) maxDepth;//加上高程
            if (this.maxDepth == 0) {
                return false;
            }
            return true;
        }

        /**
         * 深度颜色计算
         */
        public double[][] getInvertedDepthMyProfiler(final ArrayList linePoints, final int verticalIntervalPoints,
                final int horizonIntervalPoints, final int startX, final int endX, final int startZ, final int endZ, final int xDistance, final int maxDepth) {
            double tempHorizonResis[][] = null;//存储最终值
            //截取部分的长度
            int maxDepthSection = endZ - startZ;
            int xDistanceSection = endX - startX;
            String fileName = "";
            double maxDepth_Resis = -1;//最大深度下的电阻率
            //各个文件
            double[][] lineDepths = new double[linePoints.size()][];
            double[][] lineResises = new double[linePoints.size()][];
            double[][] verticalResis = new double[linePoints.size()][];
            int recMaxDepthPoint = -1;//记录最大深度在自定义测线第几个测点
            //求该侧线最大深度并记录最大深度的测点
            for (int i = 0; i < linePoints.size(); i++) {
                fileName = TEMSourceData.xy_fileName.get((ArrayList) linePoints.get(i)).toString();
                ArrayList voltage_time = TEMSourceData.integrationValue.get(fileName);
                XYSeriesCollection xyseriescollection = new XYSeriesCollection();
                TEMTime_Resis_VoltWin time_resis_rolt = new TEMTime_Resis_VoltWin(xyseriescollection);
                //获得深度与电阻率值
                XYSeries resis_depthSeries = time_resis_rolt.extractResis_Depth((ArrayList) voltage_time.get(0), (ArrayList) voltage_time.get(1),
                        (ArrayList) voltage_time.get(2), (ArrayList) voltage_time.get(3), (ArrayList) voltage_time.get(4), (ArrayList) voltage_time.get(5), (ArrayList) voltage_time.get(6));
                if (i == 0) {
                    recMaxDepthPoint = i;
                }
                if (maxDepth < resis_depthSeries.getMaxY()) {
                    recMaxDepthPoint = i;
                }
            }
            /**
             * *********************************求最大深度测点对应的视电阻率*************************************
             */
            double[] dataZ = new double[linePoints.size()];//每个测点的高程数值
            String maxDepthFileName = TEMSourceData.xy_fileName.get((ArrayList) linePoints.get(recMaxDepthPoint)).toString();
//            double maxDepthZ = TEMSourceData.z_fileName.get(maxDepthFileName);//最大深度高程值
            dataZ[recMaxDepthPoint] = TEMSourceData.z_fileName.get(maxDepthFileName);
            ArrayList maxDepth_voltage_time = TEMSourceData.integrationValue.get(maxDepthFileName);
            XYSeriesCollection maxDepth_xyseriescollection = new XYSeriesCollection();
            TEMTime_Resis_VoltWin maxDepth_time_resis_rolt = new TEMTime_Resis_VoltWin(maxDepth_xyseriescollection);
            XYSeries maxDepth_resis_depthSeries = maxDepth_time_resis_rolt.extractResis_Depth((ArrayList) maxDepth_voltage_time.get(0), (ArrayList) maxDepth_voltage_time.get(1),
                    (ArrayList) maxDepth_voltage_time.get(2), (ArrayList) maxDepth_voltage_time.get(3), (ArrayList) maxDepth_voltage_time.get(4),
                    (ArrayList) maxDepth_voltage_time.get(5), (ArrayList) maxDepth_voltage_time.get(6));
            for (int i = 0; i < maxDepth_resis_depthSeries.getItemCount(); i++) {
                if (maxDepth_resis_depthSeries.getY(i).doubleValue() == maxDepth) {
                    maxDepth_Resis = maxDepth_resis_depthSeries.getX(i).doubleValue();//获得最大深度值的电阻率
                }
            }
            int maxDepth_singlePointCount = maxDepth_resis_depthSeries.getItemCount() + 1;//加1 是 将深度为0和最大深度的值
            lineDepths[recMaxDepthPoint] = new double[maxDepth_singlePointCount];
            lineResises[recMaxDepthPoint] = new double[maxDepth_singlePointCount];
            HashMap<Double, Double> maxDepth_d_r = new HashMap<Double, Double>();//将求最大深度和电阻率值一一对应
            // 将深度为0的值是0
            lineDepths[recMaxDepthPoint][0] = 0;
            lineResises[recMaxDepthPoint][0] = 0;
            //为自定义测点数组赋值 将深度和电阻率分开
            for (int j = 1; j < lineDepths[recMaxDepthPoint].length; j++) {
                lineResises[recMaxDepthPoint][j] = maxDepth_resis_depthSeries.getX(j - 1).doubleValue();//x是电阻率
                lineDepths[recMaxDepthPoint][j] = maxDepth_resis_depthSeries.getY(j - 1).doubleValue();//y是反演深度值
            }
            double[] maxDepth_tempDepth = new double[lineDepths[recMaxDepthPoint].length];
            for (int j = 0; j < maxDepth_tempDepth.length; j++) {
                maxDepth_tempDepth[j] = lineDepths[recMaxDepthPoint][j];
                maxDepth_d_r.put(lineDepths[recMaxDepthPoint][j], lineResises[recMaxDepthPoint][j]);
            }
            Arrays.sort(maxDepth_tempDepth);//排列深度 为了找到特定的深度下的前后深度值
            lineDepths[recMaxDepthPoint][0] = maxDepth_tempDepth[1];
            lineResises[recMaxDepthPoint][0] = maxDepth_d_r.get(maxDepth_tempDepth[1]);
            double maxDepth_depthInterval = Math.ceil(maxDepthSection) / (verticalIntervalPoints - 1);//加上高程值
            double[] maxDepth_tempDep = new double[verticalIntervalPoints];
            double[] maxDepth_tempRes = new double[verticalIntervalPoints];
            verticalResis[recMaxDepthPoint] = new double[verticalIntervalPoints];//为最大深度测点初始化数组
            for (int j = 0; j < maxDepth_tempDep.length; j++) {
                double maxDepth_value = startZ + j * maxDepth_depthInterval;//求此深度
                maxDepth_tempDep[j] = maxDepth_value;//深度坐标
                int maxDepth_recPos = -1;
                for (int m = 0; m < maxDepth_tempDepth.length; m++) {
                    if (maxDepth_tempDepth[m] > maxDepth_value) {
                        maxDepth_recPos = m;
                        break;
                    }
                }
                double[] maxDepth_dds = new double[5];//三项式子中的系数 第四个是插值结果
                double[] maxDepth_D = new double[2];//只需要深度值的前后两个值进行插值计算
                double[] maxDepth_R = new double[2];//与深度值的前后两个值对应的电阻率值
                if (maxDepth_recPos != -1) {
                    maxDepth_D[0] = maxDepth_tempDepth[maxDepth_recPos - 1];
                    maxDepth_D[1] = maxDepth_tempDepth[maxDepth_recPos];
                    maxDepth_R[0] = maxDepth_d_r.get(maxDepth_D[0]);
                    maxDepth_R[1] = maxDepth_d_r.get(maxDepth_D[1]);
                } else {//当超过实际深度时 只选择 实际深度点和添加的最大深度点进行插值
                    maxDepth_D[0] = maxDepth_tempDepth[ maxDepth_tempDepth.length - 1];
                    maxDepth_D[1] = (int) Math.ceil(maxDepth);
                    maxDepth_R[0] = maxDepth_d_r.get(maxDepth_D[0]);
                    maxDepth_R[1] = maxDepth_Resis;
                }
//                maxDepth_tempRes[j] = Interpolation.getValueLagrange3(maxDepth_D.length, maxDepth_D, maxDepth_R, maxDepth_value);
                maxDepth_tempRes[j] = Interpolation.getValueAkima(maxDepth_D.length, maxDepth_D, maxDepth_R, maxDepth_value, maxDepth_dds, -1);
            }
            verticalResis[recMaxDepthPoint] = maxDepth_tempRes;//将 maxDepth_tempRes[j] 全部赋值给类对象
            /**
             * *********************************求除了最大深度测点之外的点对应的视电阻率*************************************
             */
            //建立等深度数据数组 除了最大深度测点之外
            for (int i = 0; i < linePoints.size(); i++) {
                if (i != recMaxDepthPoint) {//除了最大深度点之外的所有点进行插值计算
                    fileName = TEMSourceData.xy_fileName.get((ArrayList) linePoints.get(i)).toString();
                    dataZ[i] = TEMSourceData.z_fileName.get(fileName);//高程值
                    ArrayList voltage_time = TEMSourceData.integrationValue.get(fileName);
                    XYSeriesCollection xyseriescollection = new XYSeriesCollection();
                    TEMTime_Resis_VoltWin time_resis_rolt = new TEMTime_Resis_VoltWin(xyseriescollection);
                    //获得深度与电阻率值
                    XYSeries resis_depthSeries = time_resis_rolt.extractResis_Depth((ArrayList) voltage_time.get(0), (ArrayList) voltage_time.get(1),
                            (ArrayList) voltage_time.get(2), (ArrayList) voltage_time.get(3), (ArrayList) voltage_time.get(4), (ArrayList) voltage_time.get(5), (ArrayList) voltage_time.get(6));
                    //为resiss depths 数组赋值
                    int singlePointCount = resis_depthSeries.getItemCount() + 2;//加1 是 将深度为0和最大深度的值
                    lineDepths[i] = new double[singlePointCount];
                    lineResises[i] = new double[singlePointCount];
                    HashMap<Double, Double> d_r = new HashMap<Double, Double>();//将求的深度和电阻率值一一对应
                    // 将深度为0的值是0
                    lineDepths[i][0] = 0;
                    lineResises[i][0] = 0;
                    //为自定义测点数组赋值 将深度和电阻率分开 长度必须是lineDepths[i].length - 1
                    for (int j = 1; j < lineDepths[i].length - 1; j++) {
                        lineResises[i][j] = resis_depthSeries.getX(j - 1).doubleValue();//x是电阻率
                        lineDepths[i][j] = resis_depthSeries.getY(j - 1).doubleValue();//y是反演深度值
                    }
                    //每个测点的最大深度设为整数 对应的电阻率值
                    int maxDepthPoint = (int) Math.floor(resis_depthSeries.getMaxY());//最大深度测点的最大深度
//                    double[] dds1 = new double[5];//三项式子中的系数 第四个是插值结果
//                    double[] D1 = new double[2];//只需要深度值的前后两个值进行插值计算
//                    D1[0] = tempDepth[tempDepth.length - 1];
//                    D1[1] = tempDepth[tempDepth.length - 2];
//                    double[] R1 = new double[2];//与深度值的前后两个值对应的电阻率值
//                    R1[0] = d_r.get(D1[0]);
//                    R1[1] = d_r.get(D1[1]);
                    //不足最大深度的测点 根据比例建立最大深度
                    for (int j = 0; j < maxDepth_tempDep.length; j++) {
                        if (maxDepthPoint == maxDepth_tempDep[j]) {//该测点的最大深度与最大深度测点深度相同的位置
                            double resis = maxDepth_tempRes[maxDepth_tempRes.length - 1];//最大深度对应的数值
                            //单个测点数据中 添加最大深度和对应的电阻率值
                            lineDepths[i][singlePointCount - 1] = (int) Math.ceil(maxDepth);
                            lineResises[i][singlePointCount - 1] = resis;
                            break;
                        }
                    }
//                    lineDepths[i][0] = lineDepths[i][1];
//                    lineResises[i][0] = d_r.get(lineDepths[i][1]);
                    //给个测点下的深度范围
                    double[] tempDepth = new double[lineDepths[i].length];
                    for (int j = 0; j < tempDepth.length; j++) {//最后一个存放 最大深度值和视电阻率
                        tempDepth[j] = lineDepths[i][j];
                        d_r.put(lineDepths[i][j], lineResises[i][j]);
                    }
                    Arrays.sort(tempDepth);//排列深度 为了找到特定的深度下的前后深度值
                    //**************进行插值计算 按照间隔为depthInterval米开始0 1 2 3。。。。 为了将所有的测点数值统一*********************
                    depthInterval = maxDepthSection * 1.0 / (verticalIntervalPoints - 1);//必须是 ceil 最大深度为最大整数 从零计数的
                    double[] tempDep = new double[verticalIntervalPoints];
                    double[] tempRes = new double[verticalIntervalPoints];
                    verticalResis[i] = new double[verticalIntervalPoints];
                    for (int j = 0; j < tempDep.length; j++) {
                        double value = startZ + j * depthInterval;//求此深度
                        tempDep[j] = value;//深度坐标
                        int recPos = -1;
//                        System.out.println(value);
                        for (int m = 0; m < tempDepth.length; m++) {
                            if (tempDepth[m] > value) {
                                recPos = m;
                                break;
                            }
                        }
                        double[] dds = new double[5];//三项式子中的系数 第四个是插值结果
                        double[] D = new double[2];//只需要深度值的前后两个值进行插值计算
                        double[] R = new double[2];//与深度值的前后两个值对应的电阻率值
                        if (recPos != -1) {
                            D[0] = tempDepth[recPos - 1];
                            D[1] = tempDepth[recPos];
                            R[0] = d_r.get(D[0]);
                            R[1] = d_r.get(D[1]);
                        } else {//当超过实际深度时 只选择 实际深度点和添加的最大深度点进行插值
                            D[0] = tempDepth[tempDepth.length - 1];
                            D[1] = (int) Math.ceil(maxDepth);
                            R[0] = d_r.get(D[0]);
                            R[1] = maxDepth_tempRes[maxDepth_tempRes.length - 1];
                        }
                        tempRes[j] = Interpolation.getValueAkima(D.length, D, R, tempDep[j], dds, -1);
                    }
                    verticalResis[i] = tempRes;
                }
            }
            //水平方向进行插值
            int xpoints = horizonIntervalPoints;
            //水平垂直点数及代表的实际距离
            xInterval = xDistanceSection * 1.0 / (xpoints - 1);
            //为数组中的点赋值 
            double[][] tempHorResis = new double[verticalIntervalPoints][verticalResis.length];//垂直向层数根据垂直向插值数据点数 水平向：水平向点数
            for (int i = 0; i < verticalResis.length; i++) {//verticalResis.length
                for (int j = 0; j < verticalResis[i].length; j++) {//
                    tempHorResis[j][i] = verticalResis[i][j];
                }
            }
            //水平方向插值
            tempHorizonResis = new double[verticalIntervalPoints][xpoints];
            double[] posX = new double[linePoints.size()]; //测点的间距 可以等间距或者任意间距
//            double intervalX = 0;//两个测点代表的实际距离
//            intervalX = xDistance * 1.0 / (linePoints.size() - 1);//测线测点间隔  有时会出现不等间距
            //实际距离无投影时
            ArrayList<Double> posXY = (ArrayList) linePoints.get(0);//单点坐标 起点
            double staX = posXY.get(0);
            double staY = posXY.get(1);
            double[] intervalPoints = new double[linePoints.size()];//水平存储测点间隔之间的插值数据点数
            for (int i = 0; i < posX.length; i++) {
                ArrayList<Double> tempPosXY = (ArrayList) linePoints.get(i);//单点坐标
                double x = tempPosXY.get(0);
                double y = tempPosXY.get(1);
                double distance = Math.sqrt(Math.pow(x - staX, 2) + Math.pow(y - staY, 2));
                posX[i] = distance;
                intervalPoints[i] = distance / xInterval;
            }
            //**********************加入高程******************************************************************
            offsetZ = new double[horizonIntervalPoints];//只在水平方向上有起伏
            int recCounts = 0;
            for (int j = 0; j < intervalPoints.length - 1; j++) {
                double counts = intervalPoints[j + 1] - intervalPoints[j];
                double intervalZ = (dataZ[j + 1] - dataZ[j]) * 1.0 / counts;
                for (int i = 0; i < counts; i++) {//全部给offsetZ赋值完毕
                    if (recCounts < intervalPoints[j + 1] && recCounts < horizonIntervalPoints) {//为了保证精度 
                        offsetZ[recCounts] = (dataZ[j] - maxElevation + intervalZ * i) / depthInterval;//必须是相对距离 需要减去起始点的高程值
                        recCounts++;
                    }
                }
            }
            //不足时补充前面的高程值
            if (recCounts - 1 < horizonIntervalPoints) {
                for (int i = recCounts - 1; i < horizonIntervalPoints; i++) {
                    offsetZ[i] = offsetZ[recCounts - 1];
                }
            }
            //根据深度顺序给horizonResis赋值
            double[] dds = new double[5];
            int layers = tempHorizonResis.length;
            int unitLayerPoints = xpoints;
            for (int i = 0; i < layers; i++) {
                double[] value = tempHorResis[i];//数据量等于测点数
                for (int j = 0; j < unitLayerPoints; j++) {
                    double xPointPos = startX + j * xInterval;
                    tempHorizonResis[i][j] = Interpolation.getValueAkima(posX.length, posX, value, xPointPos, dds, -1);
//                    tempHorizonResis[i][j] = Interpolation.getValueAitken(posX.length, posX, value, xPointPos,0.000001);
                }
            }
            waitingProgressBar.setVisible(false);//等待进度条不可见
//            profileMapPanel.repaint();//计算完需重新绘制才可见
            appplyButtonActionPerformed(null);
            return tempHorizonResis;
        }

        /**
         * 选定任意深度任意/任意水平方向内的坡面图
         *
         * @param tempHorizonResis
         * @param startX
         * @param endX
         * @param startZ
         * @param endZ
         */
        public void sectionChoice(double[][] tempHorizonResis, int verticalIntervalPoints,
                int horizonIntervalPoints, int startX, int endX, int startZ, int endZ, Graphics g) {
//            int distance = endX - startX;
//            int depth = endZ - startZ;
//            double intervalXSection = distance * 1.0 / (horizonIntervalPoints - 1);
//            double intervalZSection = depth * 1.0 / (verticalIntervalPoints - 1);
//            double[][] sectionResis = new double[verticalIntervalPoints][horizonIntervalPoints];
//            double[] dds = new double[5];
//            //深度插值
//            int counts = 0;
//            double[] tempResis1 = new double[2];
//            double[] tempDep = new double[2];
//            for (int i = 0; i < layers; i++) {
//                double tempDepth = i * depthInterval;
//                double z = startZ + counts * intervalZSection;
//                if (tempDepth > z && endZ >= tempDepth) {//当大于起始深度的时候
//                    for (int j = 0; j < unitLayerPoints; j++) {
//                        tempResis1[0] = tempHorizonResis[i - 1][j];
//                        tempResis1[1] = tempHorizonResis[i][j];
//                        tempDep[0] = (i - 1) * depthInterval;
//                        tempDep[1] = i * depthInterval;
//                        sectionResis[counts][j] = Interpolation.getValueAkima(2, tempDep, tempResis1, z, dds, -1);//z等间距 间隔是intervalX
//                    }
//                    i = 0;
//                    counts++;
//                    if (counts >= verticalIntervalPoints) {
//                        break;
//                    }
//                }
//            }
//            //水平插值
//            int countsX = 0;
//            double[] tempResis2 = new double[2];
//            double[] tempHor = new double[2];
//            for (int i = 0; i < layers; i++) {
//                for (int j = 0; j < unitLayerPoints; j++) {
//                    double tempX = j * xInterval;
//                    double x = startX + countsX * intervalXSection;
////                    System.out.println(x);
//                    if (tempX > x) {
//                        tempResis2[0] = tempHorizonResis[i][j - 1];
//                        tempResis2[1] = tempHorizonResis[i][j];
//                        tempHor[0] = (j - 1) * xInterval;
//                        tempHor[1] = j * xInterval;
//                        sectionResis[i][countsX] = Interpolation.getValueAkima(2, tempHor, tempResis2, x, dds, -1);//x等间距 间隔是intervalX
//                        j = 0;
//                        countsX++;
//                        if (countsX >= horizonIntervalPoints) {
////                            System.out.println(2222222);
//                            break;
//                        }
//                    }
//                }
//                countsX = 0;//必须还原为零
////                System.out.println(333333);
//            }
            //***********************************绘制色谱图****************************************
            int layers = verticalIntervalPoints;
            int unitLayerPoints = horizonIntervalPoints;
            //设定色表值
            Color[] colors = null;
            if (colorCells == null) {
                colors = Gradient.GRADIENT_RAINBOW;//获得所选的颜色
            } else {
                colors = colorCells[colorComboBox.getSelectedIndex()].getCellColor();//获得所选的颜色
            }
            //最大最小值设定
            minValue = 0D;
            maxValue = maxResis;
            double intervalLine = (maxValue - minValue) / (colors.length - 1);
            logFactor = Double.parseDouble(logFactorsSpinner.getValue().toString());
            if (logRadioButton.isSelected()) {
                minValue = Double.parseDouble(startValueFormattedTextField.getValue().toString());
                maxValue = minValue * Math.pow(logFactor, colors.length - 3);
            }
            double minSpinnerValue = Double.parseDouble(minSpinner.getValue().toString());
            double maxSpinnerValue = Double.parseDouble(maxSpinner.getValue().toString());
            //判断最大最小值是否和设定的值大小相等
            if (minSpinnerValue != minValue) {
                if (lineRadioButton.isSelected()) {
                    minValue = minSpinnerValue;
                } else if (logRadioButton.isSelected()) {
                }
            }
            if (maxSpinnerValue != maxValue) {
                if (lineRadioButton.isSelected()) {
                    maxValue = maxSpinnerValue;
                } else if (logRadioButton.isSelected()) {
                }
            }
            //设置渐变色
//            int[][] zzz = new int[layers][unitLayerPoints];
            //给高程坐标赋值
//            for (int i = 0; i < unitLayerPoints; i++) {
//                for (int j = 0; j < layers; j++) {
//                    if (j == 0) {
//                        zzz[j][i] = offsetZ[i];
//                    } else {
//                        zzz[j][i] = zzz[0][i];
//                    }
//                }
//            }
            //先存储色标上的坐标值
            double[] colorsValue = new double[colors.length];//存储色标值
            for (int i = 0; i < colors.length; i++) {
                if (lineRadioButton.isSelected()) {
                    colorsValue[i] = minValue + intervalLine * i;
                } else if (logRadioButton.isSelected()) {
                    colorsValue[i] = minValue * Math.pow(logFactor, i);
                }
            }
            //*********************************************绘制电阻率剖面图*************************************
            for (int i = 0; i < layers; i++) {
                for (int j = 0; j < unitLayerPoints; j++) {
                    for (int m = 0; m < colors.length; m++) {
                        if (lineRadioButton.isSelected()) {
                            int yPos = (int) (offsetZTop + i - offsetZ[j]);
                            if (m != 0 && tempHorizonResis[i][j] >= colorsValue[m - 1] && tempHorizonResis[i][j] < colorsValue[m]) {
                                g.setColor(colors[m]);
                                g.fillRect(offsetX + j, yPos, 1, 1);
                            } else if (tempHorizonResis[i][j] >= colorsValue[m] && m == colors.length - 1) {//最后一个点之后的值
                                g.setColor(colors[m]);
                                g.fillRect(offsetX + j, yPos, 1, 1);
                            } else if (tempHorizonResis[i][j] < minValue) {//包括小于零
                                g.setColor(colors[0]);
                                g.fillRect(offsetX + j, yPos, 1, 1);
                            } else if (tempHorizonResis[i][j] > maxValue) {
                                g.setColor(colors[colors.length - 1]);
                                g.fillRect(offsetX + j, yPos, 1, 1);
                            }
                        } else if (logRadioButton.isSelected()) {
                            int yPos = (int) (offsetZTop + i - offsetZ[j]);
                            if (m != 0 && Math.abs(tempHorizonResis[i][j]) >= colorsValue[m - 1] && Math.abs(tempHorizonResis[i][j]) < colorsValue[m]) {
                                g.setColor(colors[m]);
                                g.fillRect(offsetX + j, yPos, 1, 1);
                            } else if (Math.abs(tempHorizonResis[i][j]) >= colorsValue[m] && m == colors.length - 1) {//最后一个点之后的值
                                g.setColor(colors[m]);
                                g.fillRect(offsetX + j, yPos, 1, 1);
                            } else if (Math.abs(tempHorizonResis[i][j]) < minValue) {
                                g.setColor(colors[0]);
                                g.fillRect(offsetX + j, yPos, 1, 1);
                            } else if (Math.abs(tempHorizonResis[i][j]) > maxValue) {
                                g.setColor(colors[colors.length - 1]);
                                g.fillRect(offsetX + j, yPos, 1, 1);
                            }
                        }
                    }
                }
            }
        }
        /*
         * 设置竖向的文字
         */

        public void setRationStr(Graphics g, String name, int x, int y, JPanel panel) {
            Graphics2D g2Rotate = (Graphics2D) g;//字体旋转
            g2Rotate.rotate(-(3.1415926 / 2), x, y);//旋转 
            g.drawString(name, x, y);//要旋转的文本 
            g2Rotate.rotate((3.1415926 / 2), x, y);//转回来 
        }

        public void setAixs(Graphics g, int usedHeight, double maxElevation, int usedWidth, int startX, int endX, int startZ, int endZ, double minValue, double maxValue, double logFactor) {
            //设定字体
            Font f = new Font("SansSerif", Font.PLAIN, 11);
            g.setFont(f);
            int xDistance = endX - startX;
            int maxDepth = endZ - startZ;
            //水平方向坐标
            String xDistanceStr = String.valueOf(xDistance);//水平向的单位最大长度个数
            int xDistanceLength = (xDistanceStr.length() + 5) * singleCharWidth;//坐标之间的间隔不能小于此间隔 像素单位
            double intervalX = xDistance * 1.0 / usedWidth;
            int intervalDistance = (int) (xDistanceLength * intervalX);
            int showIntervalDistance = 1;//实际最小间隔
            int counts = 1;
            while (intervalDistance * 1.0 / showIntervalDistance > 1) {
                if (intervalDistance <= 5) {
                    if (intervalDistance < 1) {
                        showIntervalDistance = 1;
                    } else {
                        showIntervalDistance = 5;
                    }
                } else {
                    showIntervalDistance = counts * 10;
                    counts++;
                }
            }
            intervalX = showIntervalDistance / intervalX;
            double xDistanceCounts = usedWidth * 1.0 / intervalX;//划分坐标个数
            DecimalFormat format = new DecimalFormat("0");
            for (int i = 0; i < xDistanceCounts; i++) {
                int x = (int) (offsetX + i * intervalX);
                int y = offsetZTop;
                String valueStr = format.format(startX + showIntervalDistance * i);
                int lenthString = String.valueOf(valueStr).length() * singleCharWidth / 2;
                g.setColor(Color.black);
                g.drawString(valueStr, x - lenthString, y - 5);
                g.setColor(Color.GRAY);
                g.drawLine(x, y, x, y - 3);
            }
            //垂直方向坐标
            counts = 1;
            int maxDepthLength = 5 * singleCharWidth;//坐标之间的间隔不能小于此间隔 像素单位
            maxDepth = (int) (maxIntervalZ + maxDepth);
            double intervalZ = maxDepth * 1.0 / usedHeight;
            int intervalDepth = (int) (maxDepthLength * intervalZ);
            int showIntervalDepth = 1;//实际最小间隔
            while (intervalDepth * 1.0 / showIntervalDepth > 1) {
                if (intervalDepth <= 5) {
                    if (intervalDepth < 1) {
                        showIntervalDepth = 1;
                    } else {
                        showIntervalDepth = 5;
                    }
                } else {
                    showIntervalDepth = counts * 10;
                    counts++;
                }
            }
            intervalZ = showIntervalDepth / intervalZ;
            double maxDepthCounts = usedHeight * 1.0 / intervalZ;//划分坐标个数
            int lenthString = 0;//高程坐标的像素长度
            for (int i = 0; i < maxDepthCounts; i++) {
                int y = (int) (offsetZTop + i * intervalZ);
                String valueStr = format.format(maxElevation - (startZ + showIntervalDepth * i));
                lenthString = String.valueOf(valueStr).length() * singleCharWidth;
                int x = offsetX;
                //左坐标
                g.setColor(Color.black);
                g.drawString(valueStr, x - lenthString - 5, y + singleCharWidth / 2);
                g.setColor(Color.GRAY);
                g.drawLine(x, y, x - 3, y);
                //右坐标
                g.setColor(Color.black);
                g.drawString(valueStr, offsetX + usedWidth + 8, y + singleCharWidth / 2);
                g.setColor(Color.GRAY);
                g.drawLine(offsetX + usedWidth, y, offsetX + usedWidth + 3, y);
            }
            //绘制外边框
            g.setColor(Color.black);
            g.drawRect(offsetX, offsetZTop, usedWidth, usedHeight);
            //**********************绘制色标*************************************
            //设定色表值
            Color[] colors = null;
            if (colorCells == null) {
                colors = Gradient.GRADIENT_RAINBOW;//获得所选的颜色
            } else {
                colors = colorCells[colorComboBox.getSelectedIndex()].getCellColor();//获得所选的颜色
            }
            double colorBarWidth = usedWidth * 2.0 / 3;//horizonIntervalPoints = usedWidth
            int colorBarHeight = 15;
            double interval = colorBarWidth / (colors.length);
            int startColorBarX = offsetX + (int) ((usedWidth - colorBarWidth) / 2);//绘制的起始点x
            int startColorBarY = (int) (offsetZTop + usedHeight + colorBarHeight);//绘制的起始点y
            for (int i = 0; i < colors.length; i++) {
                g.setColor(colors[i]);
                g.fillRect(startColorBarX + (int) Math.ceil(interval * i), startColorBarY, (int) Math.ceil(interval), colorBarHeight);
            }
            //色标边框
            g.setColor(Color.BLACK);
            g.drawRect(startColorBarX, startColorBarY, (int) Math.ceil(colors.length * interval), colorBarHeight);
            //色标值大小
            String maxValueStr = String.valueOf((int) maxValue);
            int unitInterval = (maxValueStr.length() + 3) * singleCharWidth;//色标值的最小间距
            double unitPixelValue = (maxValue - minValue) / (colorBarWidth - 2 * interval);//第一个和最后一个需减掉 这两个用于自定义最大最小之外的颜色
            int intervalColorBlocks = (int) Math.ceil(unitInterval / interval);//跨几个色标块
            unitInterval = (int) (intervalColorBlocks * interval);//最小宽度 像素值
            //设定字体
            Font f1 = new Font("SansSerif", Font.PLAIN, 10);
            g.setFont(f1);
            DecimalFormat format1 = new DecimalFormat("0.0");
            //只显示一个重复数字
            double onlyValue = -1;
            for (int i = 1; i < colors.length; i++) {//不第一个最后一个
                if (i % intervalColorBlocks == 0) {
                    if (lineRadioButton.isSelected()) {
                        double value = Double.parseDouble(format1.format(minValue + i * interval * unitPixelValue));
                        if (i == 1) {
                            onlyValue = value;
                            g.setColor(Color.BLACK);
                            g.drawString(value + "", startColorBarX + (int) (i * interval), startColorBarY + colorBarHeight + 10);
                        }
                        if (onlyValue != value) {
                            g.setColor(Color.BLACK);
                            g.drawString(value + "", startColorBarX + (int) (i * interval), startColorBarY + colorBarHeight + 10);
                            onlyValue = value;
                        }
                    } else if (logRadioButton.isSelected()) {
                        double value = Double.parseDouble(format1.format(minValue * Math.pow(logFactor, (i - 1))));
                        if (i == 1) {
                            onlyValue = value;
                            g.setColor(Color.BLACK);
                            g.drawString(value + "", startColorBarX + (int) (i * interval), startColorBarY + colorBarHeight + 10);
                        }
                        if (onlyValue != value) {
                            g.setColor(Color.BLACK);
                            g.drawString(value + "", startColorBarX + (int) (i * interval), startColorBarY + colorBarHeight + 10);
                            onlyValue = value;
                        }
                    }
                }
            }
            //设定色标内容
            Font f2 = new Font("SansSerif", Font.BOLD, 12);
            g.setFont(f2);
            g.setColor(Color.BLUE);
            g.drawString("Resistivity ( ohm.m )", offsetX + usedWidth / 2 - 50, startColorBarY + colorBarHeight + 25);
            //设定水平 和深度单位标题
            g.drawString("Distance ( m )", offsetX + usedWidth / 2 - 35, offsetZTop - 25);
            setRationStr(g, "Elevation ( m )", offsetX - lenthString - 15, offsetZTop + usedHeight / 2 + 30, this);
            //设定剖面标题
            Font f3 = new Font("宋体", Font.BOLD, 20);
            g.setFont(f3);
            g.setColor(Color.RED);
            String lineNameStr = lineName + "测线电阻率-深度剖面图";
            int length = lineNameStr.length() * 15;//文字的长度
            g.drawString(lineNameStr, offsetX + (usedWidth - length) / 2, (int) (offsetZTop / 2.5));
        }
    }
}
